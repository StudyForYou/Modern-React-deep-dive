# 모던 리액트 Deep Dive 스터디 week2

## 리액트 개발을 위해 꼭 알아야 할 자바스크립트: 리액트에서 자주 사용하는 자바스크립트 문법

리액트의 독특한 특징을 이해하려면 리액트에서 자주 사용되는 자바스크립트 문법을 이해해야 한다. 그리고 자바스크립트 문법을 이해한다면 반대로 리액트가 어떻게 작동되는지도 이해할 수 있다. 자바스크립트 표준을 `ECMAScript`라고 하는데, 모든 브라우저와 자바스크립트 런타임이 항상 새로운 자바스크립트 문법을 지원하는 것이 아니기 때문에 어느 `ECMAScript` 버전에서 만들어졌는지도 파악해야 한다. 셋톱박스와 같이 업데이트를 쉽게 할 수 없는 구형 기기에서는 ES5만 동작하는 경우가 있으므로 ES5 기준으로 트랜스파일된 코드를 파악하는 것이 중요하다.

### 구조 분해 할당(Destructuring assignment)

#### useState가 객체가 아닌 배열을 반환하는 이유?

객체 구조 분해 할당의 경우 사용하는 쪽에서 원하는 이름으로 변경하는 것이 번거롭다. 다만 배열 구조 분해 할당은 자유롭게 이름을 선언할 수 있기 때문에 useState는 배열을 반환하는 것으로 추측할 수 있다.

#### 배열 구조 분해 할당; 기본값

사용하고자 하는 배열의 길이가 짧거나 값이 없는 경우네는(undefined) 기본값을 사용할 것
=> undefined일 때만 기본값 사용

```js
const [a = 1, b = 1, c = 1, d = 1, e = 1] = [undefined, null, 0, ""];

a; // 1
b; // null
c; // 0
d; // ''
e; // 1
```

#### 객체 구조 분해 할당

배열 구조 분해 할당과는 달리, 객체는 객체 내부 이름으로 꺼내온다는 차이가 있다. 객체 구조 분해 할당의 경우 트랜스파일을 거치면 번들링 크기가 상대적으로 크기 때문에 만약 자신의 웹 애플리케이션 개발 환경이 ES5를 고려해야 하고, 또 객체 구조 분해 할당을 자주 쓰지 않는다면 꼭 써야 하는지 검토할 필요가 있다. 만약 객체 구조 분해 할당에 대한 트랜스파일은 부담스럽지만 객체 구조 분해 할당을 통한 `...rest`와 같은 함수가 필요하다면 외부 라이브러리를 사용해 보는 것도 고려해 봄 직하다.

- `lodash.omit` 이나 `rambda.omit`

<br/>

### 전개 구문(Spread Syntax)

배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 말 그대로 전개해 간결하게 사용할 수 있는 구문. 배열 전개 구문은 ES6(ES2015)에서, 객체 전개 구문은 ECMA2018에서 선보였다.

#### 배열 전개 구문

```js
const arr1 = ["a", "b"];
const arr2 = arr1;

arr1 === arr2; //  true. 내용이 아닌 참조를 복사하기 때문에 true 반환

const arr1 = ["a", "b"];
const arr2 = [...arr1];

arr1 === arr2; //  false. 실제로 값만 복사됐을 뿐, 참조는 다르므로 false가 반환
```

#### 객체 전개 구문

객체 전개 구문에 있어서는 순서가 중요하다. 전개 구문에 있는 값을 덮어쓸 것인지, 혹은 그 값을 받아들일지에 따라 순서에 차이가 발생한다.

```js
const obj = {
  a: 1,
  b: 1,
  c: 1,
  d: 1,
  e: 1,
};

// {a: 1, b: 1, c: 10, d: 1, e: 1}
const aObj = {
  ...obj,
  c: 10,
};

// {c: 1, a: 1, b: 1, d: 1, e: 1}
const bObj = {
  c: 10,
  ...obj,
};
```

그리고 객체 구조 분해 할당과 마찬가지로, 객체 전개 연사자 또한 트랜스파일되면 상대적으로 번들링이 커지기 때문에 사용할 때 주의할 필요가 있다.

### 객체 초기자(object shorthand assignment)

```js
const a = 1;
const b = 2;

const obj = {
  a,
  b,
};

// {a: 1, b: 2}
```

### Array 프로토타입의 메서드: map, filter, reduce, forEach

`Array.prototype.map`, `Array.prototype.filter`, `Array.prototype.reduce`는 JSX 내부에서 배열을 조작해 바로 원하는 JSX를 반환하는 특성상 굉장히 자주 쓰인다. 그리고 이 메서드는 기존 배열의 값을 건드리지 않고 새로운 값을 만들어 내기 때문에 기존 ㄱ밧이 변경될 염려 없이 안전하게 사용할 수 있다. 그리고 `forEach`까지 포함한 4개의 메서드는 ES5에서부터 사용한 문법이기에 별도의 트랜스파일이나 폴리필이 없어도 부담 없이 사용 가능하다.

#### Array.prototype.map

인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드이다. 배열의 각 아이템을 순회하면서 각 아이템을 콜백으로 연산한 결과로 구성된 새로운 배열을 만든다. 리액트에서는 주로 특정 배열을 기반으로 어떠한 리액트 요소를 반환하고자 할 때 많이 사용한다.

```js
const arr = [1, 2, 3, 4, 5];
const Elements = arr.map((item) => {
  return <Fragment key={item}>{item}</Fragment>;
});
```

#### Array.prototype.filter

콜백 함수를 인수로 받는데, 이 콜백 함숭에서 truthy 조건을 만족하는 경우에만 해당 원소를 반환하는 메서드이다. filter의 결과에 따라 원본 배열의 길이 이하의 새로운 배열이 반환된다.

#### Array.prototype.reduce

콜백 함수와 함께 초깃값을 추가로 인수를 받는데, 이 초깃값에 따라 배열이나 객체, 또는 그 외의 다른 무언가를 반환할 수 있는 메서드이다. 요약하자면, reducer 콜백 함수를 실행하고, 이를 초깃값에 누적해 결과를 반환한다.

#### Array.prototype.forEach

콜백 함수를 받아 배열을 순회하면서 단순히 그 콜백 함수를 실행하기만 하는 메서드이다. 즉, forEach는 아무런 반환값이 없다. 또, forEach는 실행되는 순간 에러를 던지거나 프로세스를 종료하지 않는 이상 이를 멈출 수 없다. break, return, 그 무엇을 이용해도 배열 순회를 멈출 수 없다. forEach 내부의 콜백 함수는 무조건 O(n)만큼 실행되므로 코드 작성과 실행 시에 반드시 최적화할 가능성이 있는지 검토해봐야 한다.

### 삼항 조건 연산자

JSX 내부에서 조건부로 렌더링하기 위해서 가장 널리 쓰이는 방법이다. 삼항 연사자를 중첩해서 쓰면 연산의 결과를 쉽게 예측하기 힘들기 때문에, 가급적이면 중첩해서 쓰지 않는 편이 좋다.

<hr />

ECMAScript 신규 문법을 제안하는 저장소: https://github.com/tc39/proposals
