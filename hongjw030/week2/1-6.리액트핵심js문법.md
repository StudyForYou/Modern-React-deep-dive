# 리액트에서 자주 쓰이는 js 문법 알아보기. 

## 오늘의 목차

* 구조분해할당
* 전개 구문
* 객체 초기자
* Array 프로토타입 메소드 - map, filter, reduce, forEach
* 삼항 조건 연산자
* 질문거리
* 공부 후기

***

## 0. 리액트는 js 기반 라이브러리.

지만!! 리액트코드와 일반적인 js 코드를 비교하면 좀 모습이 다르다. 리액트는 js 구문 내부에서 객체를 조작하거나, 객체의 얕은 동등 문제를 피하기 위해 객체분해 할당을 하는 등 리액트만의 독특한 특징이 있기 때문.

따라서 리액트를 잘 이해하기 위해선 리액트에서 잘 쓰이는 js 문법을 이해해야 한다.

***

## 1. 구조분해할당

`배열 혹은 객체의 값을 분해해 개별 변수에 즉시 할당하는 것이 구조 분해 할당` 이다!

배열 구조분해는 15년도에 나온 최신 문법이라, 바벨로 트렌스파일링하면 slice로 배열을 처리하거나 단순히 원본 배열에서 값을 가져오는 식으로 처리된다.

객체 구조분해는 18년도 최신 문법이다. 바벨로 트랜스파일링하면 생각보다 번들 크기가 커진다. 해당 객체와 새 객체에서 제외할 키 값도 체크해야 하고, 잠재적인 에러에 대한 예외처리들도 해야 하기 때문. 그래서 `마아안약에!! 개발환경이 ES5를 고려해야 하고, 객체구조분해할당을 자주 쓰지 않는다면 차라리 객체 구조분해는 지양하고 loadsh.omit 이나 rambda.omit 같은 라이브러리를 사용하는 것으로 대체할 수도 있다` >> 근데 이렇게까지 해야 함?? 객체 구조분해 개많이 쓰지 않나 특히 리액트에선??.... 

#### 배열 구조분해 예시

```js
const array = [1,2,3,4,5];

const [first, second, ...arrayRest] = array;
// first 1
//second 2
// arrayRest = [3, 4, 5]
// 단 주의할 점!!!! 전개연산자는 무조건 맨 뒤에 있어야 함. [...rest, first, second] 하면 에러.

const [first, , , , fifth] = array;
// first 1
// fifth 5

const smallArray = [1,2]
const [a=10, b=20, c=30] = smallArray;
//a = 1
// b =2
// c= 30

const [a=1, b=1, c=3, d=1, e=1] = [undefined, null, 0, ''];
//a = 1 => 주의!!!! 값이 undefined일 때에만 기본 값을 사용함.
//b=null
//c=0
//d=''
//3=1 => 주의!!! 배열 길이를 넘어서서 undefined로 평가되어 기본값이 할당된 케이스.
```

#### 객체 구조분해 예시

```js
const object = {a:1, b:1, c:1, d:1, e:1,};

const {a, b, c, ...objectRest} = object;
// a 1
// b 1
// c 1
// objectRest = {d:1, e:1}

const {a:first, b:second} = object;
// first 1
// second 1

const smallObject = {a:1, b:1,};
const {a=10, b=10, c=10} = smallObject;
// a 1
// b 1
// c 10

const longNameObject = {abc: 10};
let strName = "a" + "b" + "c";
const {[strName]: aaa} = longNameObject;
// aaa 10 => 즉, 계산된 속성 이름 방식도 가능함!!!!
```

***

## 2. 전개 구문

**전개 구문과 구조분해 할당은 다른 개념!!!**

전개 구문이란 `객체, 문자열, 배열 등 순회 가능한 값들을 전개할 수 있는 구문` 이다. spread 구문!!

배열 전개 구문은 15년도 문법으로, 바벨을 돌리면 `concat` 메소드로 처리된다.
반면 객체 전개 구문은 19년도 문법으로, 바벨을 돌리면 번들 크기가 상대적으로 커진다.. 

참고로 객체 구조분해할 때에 같은 키들이 있으면, 이후에 삽입된 값이 이전 값을 덮어쓰기한다.

```js
const obj1 = {a:1, b:1, c:1}
const obj2 = {a:2, d:2, e:2};

const obj = {...obj2, ...obj1} // a:1 b:1 c:1 d:2 e:2
```

***


## 3. 객체 초기자

15년도에 도입된 새로운 문법앤 객체 초기자, object shorthand assignment는 객체를 선언할 때 이미 객체에 넣고자 하는 키와 값을 가진 변수가 있다면, 그 값을 간결하게 넣어줄 수 있는 문법이다. (내가 자주 사용하던 그 문법이네!! 그걸 객체 초기자라 하는군...)

바벨로 돌려도 별도의 작업 없어 큰 부담도 없다.

#### 객체 초기자 예시

```js
const a = 1;
const b = 2;

const obj = {a, b};
```

***

## Array 프로토타입 메소드 - map, filter, reduce, forEach

jsx 내부에서 배열을 조작해 바로 원하는 jsx를 반환하는 배열 메소드는 `map, filter, reduce` 이 세 가지가 가장 많이 쓰인다. 이 셋은 기존 배열을 건드리지 않고 새 배열을 만들어 안전하다.

여기에 기본 for문인 `forEach` 까지 합해서 4개는 바벨이나 폴리필 없어도 바로 쓸 수 있다.

`map`은 이미 아니까 간략하게 말하자면.. 인수로 전달받은 배열과 똑같은 길이의 새 배열을 반환하는 메소드.

`filter` 은 아..!!! 개쩌네.. 콜백함수에서 truthy 조건을 만족한 경우만 원소를 반환해 필터링하는 메소드로, 원본 배열 길이 이하의 새 배열이 만들어짐.. map 내부에서 if return문을 쓰지 말고 filter을 쓰면 되는군... 나는 뭔짓을...

`reduce`는 좀 복잡하다. 그렇더라... 인자로 콜백함수와 initialResutl를 넘겨준다. `(result, el, ind) => {return nextResult}, initialResult` 이렇게.. 그리고 리턴값은 하나의 값이다!! 뭐 객체 하나가 될 수 있고 배열 하나가 될 수 있고 아님 sum 값이 될 수도 있고. 

#### reduce 예시.

```js
const arr = [1,2,3,4,5];

const answer = arr.reduce((result, el)=>{
  if (item %2 == 1){
    result.push(item * 10);
  }return result;
}, []);
// answer [10, 30, 50];
```

`forEach`는 그냥 일반 for문 같은데... 그치만 map, reduce, filter과 달리 반환값이 없으니 `const answer = arr.forEach(...)` 해도 answer에는 undefined 값만 들어간다.

그리고 주의할 점!!! `forEach는 에러가 나거나 프로세스 자체가 종료되지 않는 이상 return이나 break 를 써도 멈출 수 없다.` forEach의 콜백함수 안에서 return해봤자 콜백의 return으로 간주되므로 그냥 배열 길이만큼 무조건 실행돼버림. 따라서 중간에 break해야 할 경우는 forEach 안 쓰는 걸로... 아하?!? 그래서 저번 코테문제 틀렸던거군.

***

## 삼항 조건 연산자

내가 아는 그 문법. js에서 유일하게 피연산자 3개를 취할 수 있다.

`const result = value%2 == 0 ? value : value+1` 이런 식으로 쓰자.

다만 조건이 ㄹ여러 개 있으면 삼항 연산자를 중첩해서 쓰는 경우도 있는데, 코드 보기가 어려워지니 지양하자. 

***
## 질문거리

아니 대체 구조분해 바벨 번들이 얼마나 크길래 이러는 겨??

***

## 공부 후기

js 최신 코드에 대해 더 알고 싶다면 에크마 스크립트 신규 문법을 제안하는 저장소인 https://github.com/tc39/proposals를 방문해보자... 여기 제안들이 다 채택되는 건 아님.

그리고 최신 문법들을 리액트에 쓸 거라면, 바벨이나 폴리필을 통해 최신 문법을 다운그레이드할 수 있는지를 따진다면 더 안정적인 리액트 웹을 만들 수 있을 것!!

헐... 싫어.
어려워...
아니 근데 구조분해 할당도 번들 크기를 신경써야 할 정도라고??? 좀 더 알아봐야겠삼. 대체 얼마나 번들이 커지길래 이러는건지.. 그리고 방금 생각났는데 번들 최적화하는 도구 있지 않나?? 웹팩..? 아닌가? 하여간 번들 최적화도 분명 기술면접 어쩌구로 받았던 말인데 이거 좀 더 알아봐야겠음. 대체 번들이 뭐고 이걸 어떻게 최적화할 수 있을지?