## 오늘의 목차

* 자바스크립트의 동등 비교
- 1. 자바스크립트의 데이터 타입
- 2. 값을 저장하는 방식의 차이 (참조형, 원시형 데이터 타입의 차이)
- 3. js에서의 동등 비교 (==, ===, Object.is)
- 4. 리액트에서의 동등 비교
- 5. 정리.

* 공부 후기

***

## 자바스크립트의 동등 비교

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과이다.

이 때 props의 동등 비교는 객체의 얕은 비교를 기반으로 이루어지기 때문에, 리액트에선 얕은 비교가 어떻게 작동하는지를 알아야 렌더링 최적화를 개념적으로 접근할 수 있다.

***

### 1. 자바스크립트의 데이터 타입

js에는 `primitive data type`, `reference data type` 이 있다. 

1. 원시형 타입은 `boolean`, `null`, `undefined`, `number`, `string`, `bigInt`, `symbol`이 있다. ES2022 기준 현재 js는 7개의 원시형 타입을 제공함.
2. 참조형 타입은 객체(배열, 함수, 클래스, 정규식 등 포함. `원시형 타입 이외의 것들을 참조형 타입이라 보면 된다.`)이 있다.

물론 `typeof null` 하면 `object`로 출력되긴 하지만 이건 js 측 오류이다... 이제와서 수정하기엔 레거시가 너무 많아서 못 했다고 한다. 

여기서 간단하게 짚고 넘어갈 개념은...

1. `falsy, truthy` : boolean형 데이터는 아니지만 조건문 내부에서 true, false 값으로 취급되는 값들. 예를 들어 `if ("aaaa"){...}` 에서 if문 안에 있는 데이터는 string형이지만 truthy 하여 true 취급된다.
> 참고로 falsy 값은 false, 0, -0, 0n, "", NaN, null, undefined 이 있으며, truthy 값은 falsy가 아닌 나머지 값들이다. 

2. 자바스크립트는 `Number` 타입 데이터에 정수 실수 모두 넣을 수 있고, 범위도 엄청 크다. java 같은 데에선 int 범위가 +-21억 정도지만 javascript에선 그냥 어마무시하게 많다. 대충 +-10^15 정도. java로 백준 문제를 풀 때엔 허구한 날 int 범위를 넘어가면서 에러가 터졌지만, js로는 웬만해서 number 범위로 에러가 터진 경우는 거의 없었다. 
+ 하나 더 추가하자면 `2, 8, 16진수로 나타난 숫자들도 모두 Number 타입` 으로 인식된다. 예를 들어 `typeof (15).toString(2)` 하면 Number형이라고 출력됨.

3. 문자열을 나타낼 때엔 작은따옴표, 큰따옴표로 나타낼 수도 있으며 백틱을 사용해 `문자열 리터럴 표현방식` 을 쓸 수도 있다!!. 이렇게 백틱으로 나타낸 문자열을 `템플릿 리터럴, template literal`이라 하며 일반 문자열과 달리 문자열 내부에 표현식을 쓰거나 줄바꿈을 할 수 있다.
+ 참고로 문자열은 원시 타입이라 값을 바꿀 수 없다. split, slice 등의 메소드를 사용해 임의로 문자열을 자르고 수정하는 건 가능하지만 `"aaa"[2] = "b"` 이런 식으로 변경할 수 없음.


### 2. 값을 저장하는 방식의 차이 (원시타입과 객체타입을 비교해보기)

원시 타입과 객체 타입은 여러 차이점이 있겠지만, 가장 큰 차이점은 `값을 저장하는 방식` 이다.

원시 타입은 메모리에 불변 형태로 값이 저장되지만, 객체 타입은 참조값(주소)가 메모리에 저장된다. 즉, 주소만 안바뀐다면 실제 값이 바뀌든 말든 신경 안 쓰는 것.

아래는 그의 예시.

```javascript
// 객체 비교
const hi = {
  name: "인사하기"
}
const hello = {
  name: "인사하기"
}
console.log(hi === hello) // false

// 원시값 비교
const a = 1;
const b = 1;
console.log(a === b) // true
```

***

### 3. js에서의 동등 비교 (==, ===, Object.is)

기본적으로 우리가 아는 js 동등비교식은 `==`와 `===` 를 사용해서 쓴다. 근데 이거 말고 `Object.is()` 라는 메소드로도 동등 비교를 할 수 있다!!! 이 세 가지 방법의 차이에 대해 알아보자.

1. `==` 는 비교하는 두 값이 같은 타입이 아니면 지멋대로 타입을 맞춰주고 (type casting, 강제 형변환) 비교한다. `5 == "5"` 에서 true 값이 나오는 이유.

2. `===` 는 비교하는 두 값이 다른 타입이면 바로 false.

3. `Object.is` 도 `===`와 비슷하게 다른 타입간 비교는 false 처리해버린다. 다만 Object.is는 ===가 놓치는 몇 가지 케이스를 더 정확히 비교해주는 녀석이다.

예시.
```js
-0 === +0 // true
Object.is(-0, +0) // false

Number.NaN === NaN //false
Object.is(Number.NaN, NaN) // true

NaN === 0/0 // false
Object.is(NaN, 0/0) //true
```

그러나 `===` 와 `Object.is` 둘 다 객체 비교에선 똑같이 덜떨어진다.(?)

```js
Object.is({}, {}) //false
{} === {} // false
```

***

### 4. 리액트에서의 동등 비교?

**리액트는 자바스크립트 라이브러리다.**

리액트에서의 동등 비교도 자바스크립트를 기반으로 이루어진다는 뜻!

`==`, `===`, `Object.is` 중에서 리액트에서 선택한 동등 비교 방식은 `Object.is()` 이다. 이 때 Object.is는 최신 문법이기 때문에 이를 지원하지 않는 브라우저(익플이라든가..) 를 위해 폴리필을 함께 사용한다.

그리고 이 `Object.is(혹은 자체구현 폴리필)`을 활용해 `shallowEqual` 이라는 함수를 만들어 의존성 비교 등 리액트 내에서 동등비교가 필요한 여러 부분에서 사용한다!!


```js
// 이 코드는 실제 리액트에 있는 코드가 아니라 그냥 내가 짧게 줄여서 작성한 슈도코드다!!
// shallowEqual

function shallowEqual(data1, data2){
  if (Object.is(data1, data2)) => true;

  // data1, data2 가 객체형이라면...
  // data1의 모든 속성에 대해 data2와 값을 비교하여 값이 다 같다면 true.
  if (data1 is Object && data2 is Object){
    for(let key in data1){
      if (data1.key !== data2.key) => false;
    }
    => true;
  }
}

console.log(shallowEqual({}, {})) // true
```

즉!! 리액트의 `shallowEqual`은 
1. 먼저 `Object.is`로 비교한 후, 
2. `Object.is`가 안 먹히는 곳에선 객체 간 얕은 비교를 한 번 더 진행한다. 이 때 객체 간 얕은 비교란, `객체의 첫 번째 깊이에 존재하는 값만 비교`한다는 것을 의미.

```javascript
Object.is({name:"hellen"}, (name:"hellen")) // false

shallowEqual({name:"hellen"}, (name:"hellen")) // 깊이가 1일 때엔 비교하고 true

shallowEqual({name:{eng: "hellen"}}, (name:{eng: "hellen"})) // 깊이가 1보다 크면 비교 불가. false 출력!
```

***

### 5. 정리

리액트에선 어떠한 데이터를 비교할 때 `Object.is` 와 `객체의 얕은 비교`를 사용해서 비교한다.

때문에 객체의 깊이가 깊다면 예상치 못한 문제를 일으킬 수 있다. 

***

## 공부 후기

일단 내가 이해한 바로는...

객체의 깊이가 1이면 문제가 없지만, `그 이상인 객체를 컴포넌트의 인자로 전달해줄 때 shallowEqual 함수가 false(이전 데이터와 같지 않음!) 을 리턴하여 memo된 값이 아니라고 판단, 렌더링 실시!` ... 가 진행되는 것이다. 

즉, `memo` 나 `useMemo` 같이 데이터의 값에 의존하여 렌더링할지 말지 결정하는 경우, 해당 데이터의 타입이 객체고 깊이가 2 이상이라면 값이 제대로 memo되지 않아 계속 렌더링을 일으킨다는 것.

***

## 질문거리

그럼 리액트에서 props 인자로 넘겨줄 때 깊이가 2 이상인 객체를 넘기는 건 안티 패턴인가? 웬만하면 깊이가 깊은 객체를 넘기는 것은 지양해야 할 점인가?