## 오늘의 목차

자바스크립트의 동등 비교
- 1. 자바스크립트의 데이터 타입
- 2. 값을 저장하는 방식의 차이 (참조형, 원시형 데이터 타입의 차이)
- 3. js에서의 동등 비교 (==, ===, Object.is)
- 4. 리액트에서의 동등 비교
- 5. 정리.

***

## 자바스크립트의 동등 비교

리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과이다.

이 때 props의 동등 비교는 객체의 얕은 비교를 기반으로 이루어지기 때문에, 리액트에선 얕은 비교가 어떻게 작동하는지를 알아야 렌더링 최적화를 개념적으로 접근할 수 있다.

***

### 1. 자바스크립트의 데이터 타입

js에는 `primitive data type`, `reference data type` 이 있다. 알다시피 원시형 타입은 boolean, null, undefined, number, string, bigInt, symbol이 있고, 참조형 타입은 객체(배열, 함수, 클래스, 정규식 등 포함 포함)이 있다.

물론 `typeof null` 하면 `object`로 출력되긴 하지만 이건 js 측 오류이다... 이제와서 수정하기엔 레거시가 너무 많아서 못 했다고 한다. 

원시 타입과 객체 타입은 여러 차이점이 있겠지만, 가장 큰 차이점은 `값을 저장하는 방식` 이다.

원시 타입은 메모리에 불변 형태로 값이 저장되지만, 객체 타입은 참조값(주소)가 메모리에 저장된다. 즉, 주소만 안바뀐다면 실제 값이 바뀌든 말든 신경 안 쓰는 것.

***

### 2. 값을 저장하는 방식의 차이 (참조형, 원시형 데이터 타입의 차이)

***

### 3. js에서의 동등 비교 (==, ===, Object.is)

***

### 4. 리액트에서의 동등 비교?

값을 동등비교 하는 방식은 `==` , `===` , `Object.is()` 이렇게 크게 3가지가 있다. 리액트에서 사용하는 동등 비교 방식은 `Object.is() 메소드를 바탕으로 구현한 shallowEqual 함수` 이다.

`==` 와 `===` 이 두 개는 많이 봤겠지만... `Object.is()` 메소드는 ES6에서 새로 등장한 문법이다.

거의 `===`와 비슷하긴 한데, 좀 더 정확히 비교해주는 게 `Object.is()` 메소드이다.  그렇지만 `Object.is` 메소드도 객체 비교는 별 차이가 없다. 

그래서 리액트는 먼저 `Object.is`로 비교한 후, `Object.is`가 안 먹히는 곳에선 객체 간 얕은 비교를 한 번 더 진행한다. 이 때 객체 간 얕은 비교란, `객체의 첫 번째 깊이에 존재하는 값만 비교`한다는 것을 의미.

```javascript
Object.is({name:"hellen"}, (name:"hellen")) // false

shallowEqual({name:"hellen"}, (name:"hellen")) // 깊이가 1일 때엔 비교하고 true

shallowEqual({name:{eng: "hellen"}}, (name:{eng: "hellen"})) // 깊이가 1보다 크면 false
```

***

### 5. 정리

32p부턴 뭔개소리인가 모르겠어서 일단 패스.
