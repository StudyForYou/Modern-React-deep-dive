## 오늘의 목차

* 자바스크립트의 클로저 (대망의 클로저....)
1. 클로저란?
2. 스코프
3. 클로저 활용하기
4. 주의할 점
5. 정리

* 공부 후기

* 질문거리

***

## 자바스크립트의 클로저

ㅋㅋ 클로저... 제목 보자마자 아 올게 왔다 싶었다 ㅋㅋ

책 안봐도 뻔함 분명 난 첫줄 읽자마자 개처럼 깨지고 울면서 이 뭔 개소리야 이러고 있겠지...

역시 내 예언대로 지금 59p 첫줄 읽자마자 머리가 깨질거 같다.

`리액트의 클래스형 컴포넌트에 대한 이해가 js의 클래스, 프로토 타입, this에 달려있다면 함수형 컴포넌트에 대한 이해는 클로저에 달려있다.` 라고 적혀있는데 이게 뭔 뜻인지 참 ㅋㅋ

함수형 컴포넌트의 구조, 훅, dependency 배열 등등 대부분이 클로저에 의존하고 있기 때문에 클로저 개념은 필수 오브 필수다. (그리고 기술면접 1타 단골 질문이기도 함.)

쩔 수 없다 렛츠기릿~! 한 번 알아보자.

***

### 1. 클로저란?

클로저란, `함수와 함수가 선언된 렉시컬 스코프의 조합` 이라고 한다. 여기서 `렉시컬 스코프, 어휘적 환경`이 뭘까?? 그것부터 알아보자.

#### 렉시컬 스코프, 어휘적 환경.

어휘적 환경이란, 변수가 코드 어디에서 정의되어있는지를 말한다. 즉 그 변수가 어느 범위에서 사용될 수 있을지를 뜻한다. 런타임 중 동적으로 결정되는 this와는 달리, 클로저는 코드 작성 그 순간 정적으로 결정된다.

즉, 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법을 말한다.

#### 아니 그럼 `환경`은 무엇인가?

환경, scope는 변수의 유효 범위를 말한다!!! 이 부분은 많이 들어봤을테니 가볍게 개념만 짚고 넘어가자면...

### 2. 스코프

예를 들어 전역 레벨에 변수를 선언하면 그 변수는 `전역 스코프`에서 쓸 수 있게 된다.

브라우저 환경에선 window, Node js 환경에선 global이라는 이름의 전역 객체가 있는데, 전역 레벨에 선언된 변수들은 이 전역 객체에 바인딩된다. 

전역 스코프 말고는 `함수 스코프`라고 한다. js는 기본적으로 함수 레벨 스코프를 따른다. -> 즉, 중괄호 블록 자체는 스코프 범위를 결정하지 않는다는 것.

만약 스코프가 중첩되어있다면, 가장 가까운 스코프에서 먼저 변수를 찾고, 점점 범위를 확장해나간다.

** 참고로 아래는 책에 나온 건 아닌데 내가 이해가 안되서 따로 정리한 것.

ES6 기준으로 실행 컨텍스트에는 `Lexical environment`와 `variable environment`라는 게 있다.
1. `Lexical environment` 안에는 `상위 스코프의 Lexical environment 정보` + `함수, 변수, this 등 식별자 바인딩 정보` 가 들어있다.
2. `variable environment` 안에**도** `상위 스코프의 Lexical environment 정보` + `함수, 변수, this 등 식별자 바인딩 정보` 가 들어있다.

뭐야? 그럼 이 둘이 뭔 차이야?

그건 바로.. var, let, const 변수 선언방식으로 인해 이 둘을 이렇게 나눴다고 한다.

(그래서 기존 var 키워드만 있던 예전 js에선 실행컨텍스트 내부 모습도 달랐다.)

var 키워드는 함수별 스코프를 따르고, let, const는 block 스코프를 따른다. 이로 인해 var 키워드 변수와 let const 키워드 변수의 상위 스코프 참조 범위가 달라져 어쩔 수 없이 분리해둔 것이다. 그리고 let, const 키워드로 변수를 선언하면 선언문과 할당문 사이에 TDZ를 거친다. var와는 생명주기 자체가 달라서 어쩔 수 없이 분리했다는 것.

### 3. 클로저 활용하기

다시 클로저로 돌아와서, 클로저의 정의 중 `어휘적 환경`이란 결국 어떤 범위 내에서 정의된 변수나 함수 식별자 정보와, 상위 어휘환경의 정보를 합한 것들을 말한다.

클로저를 활용하면 함수 내 변수를, 중첩함수가 액세스하여 값을 조작할 수 있게된다. 중첩함수의 어휘적 환경에는 상위 어휘적 환경인 외부 함수가 포함되어있기 때문.

예를 들면 리액트의 `useState`는 클로저를 활용했다!!

`const [value, setValue] = useState(0)` 이 코드에서 value 변수에 직접적으로 값을 할당할 수 없고, setValue 함수를 통해서만 접근이 가능하다. 이는 즉 외부함수 useState의 호출이 끝났음에도 내부함수 setValue는 자신의 어휘적 환경을 기억하기 때문에 계속 value값에 접근 가능하단 것.

### 4. 주의할 점

클로저 개념은 진짜 어렵다. 

앞서 말했듯  var, let, const 키워드는 각각 variable environment, lexical environment를 참고하기 떄문에 var 키워드로 코드를 짰을 때엔 의도치 않은 다른 작동을 일으킬 수 있다. 

두 번째로... js는 실행컨텍스트로 인해 상위 어휘적 환경을 항상 기억한다지만, 브라우저의 최적화로 인해 이젠 필요할 때만 기억하고 아니면 버린다.

그래서 클로저를 일부러 활용해서 외부 환경을 기억하면 그만큼의 메모리를 잡아먹게 된다.


### 5. 정리

클로저 개념...

그니까 그냥 `protected class ...` 인거 아녀?

클로저란 함수와 함수가 정의된 어휘적 환경의 조합을 말하는데, 중첩함수가 어휘적 환경을 통해 외부 함수의 환경을 참조하여 그 값을 사용할 수 있다는 것.

때문에 useState 훅처럼 외부 함수의 호출은 이미 훅을 호출한 데에서 끝났지만 훅이 리턴하는 내부 함수를 통해 외부함수의 변수를 사용하며 어휘적 환경을 다룬다는 것이다.

이는 정보 은닉, 안정성을 높이는 등의 장점이 있다.

다만 클로저를 쓴다는 건 외부 환경을 기억하기 위해 메모리를 쓴다는 것이니 주의하자.

***

## 공부 후기

이 망할 어휘적 환경.

나중에 실행 컨텍스트부터 환경까지 전체 흐름을 공부해야할듯 싶다.

***

## 질문거리

내가 지금 뭘 이해했는지조차 이해가 안돼서 모르겠음.