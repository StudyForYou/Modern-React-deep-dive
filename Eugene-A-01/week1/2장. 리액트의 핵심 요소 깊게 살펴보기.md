# 2장. 리액트 핵심요소 Deep Dive



# 2.1 JSX란?

### 여기서 기억할것

- jsx는 트랜스파일이 필요하다
- jsx는 자바스크립트 내부에 html과 같은 트리구조를 가진 컴포넌트를 표현할 수 있다.
- 컴포넌트 작성할때에 jsx가 아닌 createElement를 이용해 직접 컴포넌트를 구성하는것이 효율적인 경우도 있다.

### JSX란?

- ECMAScript 표준 자바스크립트만으로는 표현하기 어려웠던 XML스타일의 트리구문을 작성하는데 도움을 주는 새로운 문법
- JSX는 JS표준코드가 아니기 때문에 **트랜스파일**을 거쳐야만 자바스크립트 런타임이 이해할 수 있는 JS로 변환된다.

### JSX는?

아래 네가지로 구성된다

1. **JSXElement**
    
    HTML Element와 비슷한 역할
    
2. **JSXAttribute**
    
    JSX Element에 부여하는 속성
    
    <A {…{required: true }} /> 이렇게 { } 와 전개연산자로 속성을 줘도 되고
    
    <A required /> 처럼 속성만 넣는것도 가능하다
    
3. **JSXChildren**
    
    JSXElement의 자식 값
    
4. **JSXString**
    
    

### JSX→JS 로 변환되는 방식

@babel/plugin-transform-react-jsx 플러그인이 JSX → JS로 트랜스파일한다

<A required=”true”>Hello World</A> 를 트랜스파일한 결과

```cpp
// 바벨
React.createElement(A, {required:true}, "Hello world");

// 오토런타임
var ComponentA = (0, _jsxRuntime)(A, {
	required: true,
	children; "Hello world"
)
```

### JSX의 트랜스파일링을 이해하면 할 수 있는 리팩토링

isHeading이 true라면 h1태그를, false라면 그냥 div를 return하는 컴포넌트가 있다고 하자.

```cpp

// JS 변환 후 불필요한 코드 중복이 있는 방식
// {className: "text"} 와 children은 h1과 div가 같은 값을 둘 다 갖게 된다.
function myComponent({isHeading, children}) {
	
	return 
		isHeading? ( 
			<h1 className="text">{children}</h1>
		) : (
			<div className="text">{children}</h1>
		)
}

// 리팩토링 방식
// 그냥 JSXElement만 경우에 따라 다르게 해주고
// JSXChildren이나 JSXAttribute는 동일하게 가지므로 코드 절약
function myComponent({isHeading, children}) {
	
	return createElement(
		isHeading ? 'h1' : 'div',
		{
			className: "text" // 여기랑
		},
		children // 여기는 JS 트랜스파일 후에도 중복코드 없음!
	)
}
```

### 추가공부

- ECMAScript

---

# 2.2 가상 DOM과 리액트 파이버

### 기억할것

- 리액트의 가장 큰 특징 : 가상 DOM 운영
- 가상돔이 왜 만들어졌나?
- 실제돔과는 어떤 차이가 있나?
- 가상돔이 실제돔보다 빠른가?
- 실제돔에 비해 어떤 이점이 있나?
- 가상돔을 다룰때 주의할점은 무엇인가?

### DOM과 브라우저 렌더링 과정

1. 요청한 주소의 웹사이트에 대한 HTML을 다운
2. 렌더링 엔진이 HTML 파서를 이용해 DOM트리 형성
    1. 2번 과정 중 CSS 파일을 만나면 다운
3. 렌더링 엔진이 CSS 파싱 후 CSSOM트리 형성
4. 브라우저는 DOM트리 순회
    
    단, 이때 눈에 보여지는 노드만 방문 (display:none 등은 방문하지 않음)
    
5. 순회 중 노드에 해당하는 CSSOM 정보를 찾아 스타일을 적용
    1. 레이아웃 : 좌표
    2. 페인팅 : 색 등

### 가상 DOM이란?

실제 브라우저의 DOM이 아닌 리액트(react-dom)가 관리하는 가상의 DOM

웹페이지가 표시해야할 DOM을 “**메모리에 저장**”하고 변경에 대한 준비가 되었을때 실제 DOM에 반영

### 가상 DOM이 왜 필요할까?

가상DOM이 없다면, 사용자 인터랙션에 따라 DOM이 변경되는 일이 많을때 모든 변경사항을 추적해야하고 여러번 재렌더링될것.

가상 DOM은 인터랙션들의 결과에 따른 최종 DOM 결과물을 간편하게 제공하고, 여러번 발생할 수 있는 렌더링 과정을 최소화할 수 있다

### 가상 DOM을 사용하면 더 빠르다?

실제 DOM만 사용할때보다 무조건 빠른것 NO!

가상DOM 이용방식이 웬만한 애플리케이션 렌더링에 무리없을 정도로 충분히 빠르다 YES

### 리액트 파이버

**리액트 파이버란?**

- 리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것.
- 여러번의 렌더링 과정을 압축해 최소한의 렌더링으로 만드는 렌더링 최적화를 가능하게 하는 아키텍처
- 애니메이션, 레이아웃, 사용자인터렉션에 의한 올바른 결과물을 만드는 반응성 문제 해결
- 자바스크립트 객체이며, 리액트 재조정자에 의해 관리된다.
    - 리액트 재조정자(reconciler)가 하는 일
        - 가상DOM과 실제DOM을 비교
        - 차이가 있으면 관련 파이버에 대해 렌더링 요청

**리액트 파이버가 하는 일**

아래의 모든 일들은 **비동기**로 진행된다.

- 작업을 작게 나누고 우선순위를 매긴다.
- 작업을 일시중지하고 나중에 다시 시작한다.
- 이전 작업을 재사용한다.
- 이전 작업이 필요하지 않은경우 폐기한다.

**리액트 파이버가 거치는 단계**

파이버는 하나의 작업 단위로 구성되어있다. 이 작업단위는 아래 두 단계를 거친다.

1. 렌더 단계
    - 사용자에게 노출되지 않는 모든 비동기 작업 수행
    - 우선순위 지정/중지/버림 등의 작업을 수행
    - 작업 완료 후 마무리. finishWork()
2. 커밋 단계
    - 실제 DOM 반영하는 단계. commitWork()
    - 이 단계는 동기식을 일어나며 중단될 수 없다.

**리액트 파이버 특징**

- 최초 마운트 시점에 생성되고
- 이후 가급적 재사용된다.
    
    리액트 요소 vs 파이버 : 리액트 요소는 렌더링 시마다 새롭게 생성됨 vs 파이버는 가급적 재사용됨
    

**리액트 파이버의 구현**

134-139 다시 보기

### 리액트 파이버 트리

**리액트 파이버트리는 2개가 존재한다.**

1. 현재 모습을 담은 트리 (current)
2. 작업중인 상태를 담은 트리 (workInProcess)

**두 파이버트리의 동작**

1. current 트리에 업데이트가 발생함
2. 리액트에서 받은 업데이트 데이터를 기반으로 새로운 workInProcess 트리 빌드
3. 다음 렌더링에 이 workInProcess 트리 사용
4. 렌더링되어 반영이 끝나면 workInProcess 트리의 포인터를 current로 바꿔버린다. (더블 버퍼링 기술)

**최초렌더링시 파이버트리 생성 과정**

1. 리액트가 루트노드의 beginWork() 실행 후 아래 단계를 반복
    1. 자식이 없는 파이버를 만날때까지 파이버 작업 수행
    2. 자식이 없다면 completeWork()로 파이버 작업 완료
    3. 형제가 있다면 형제의 beginWork()
    4. 자식, 형제까지 모두 끝났다면 return으로 작업 완료
2. 루트노드가 완성되는 순간 commitWork()가 수행됨. 
3. 이렇게 만들어진 파이버트리의 변경사항을 비교해 DOM에 반영

**파이버트리 재사용**

최초 렌더링 이후의 업데이트가 발생하여 workInProcess 트리를 만들때 되도록 파이버를 새로 생성하지 않는다.

앞서 만든 current트리로부터 기존 파이버에서 업데이트된 Props를 받아 파이버 내부에서 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.

---

# 2.3 클래스형 vs 함수형 컴포넌트

---

# 2.4 렌더링은 어떻게 일어나는가?

---

# 2.5 메모이제이션

---
