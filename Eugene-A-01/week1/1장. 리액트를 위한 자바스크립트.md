# 1.1 자바스크립트 동등비교 딥다이브

## 0. 왜 알아야할까?

- 리액트 의존성 배열의 prop을 판단하는것
- 가상 DOM 과 실제 DOM 의 비교
- 렌더링 방지를 위한 메모이제이션 (useMemo, useCallback, React.memo)을 위한 비교

모두 자바스크립트의 동등비교 비교 연산이 쓰인다!! 

## 1. 타입

1. **원시타입 (7)**
    
    : 불변값으로 저장됨.
    
    - null
    - undefined
    - number
    - bigint
    - string
    - boolean
    - symbol
    
2. **객체 타입(1)**
    
    : 배열, 함수, 클래스, 정규식
    
    : 변경 가능한 값으로 저장됨. 따라서 프로퍼티를 삭제,추가,수정할 수 있다. 
    
    - object

**(+ 참고) “null과 undefined의 차이”**

undefined : 선언은 했는데 할당이 안 되었을때 자동으로 할당되는 값

null : 명시적으로 비어있음을 나타내기 위해 할당한 값

## 2. 동등 비교 연산자들

1. **==**
    
    양쪽을 같은 타입으로 맞춘 뒤 (type casting) 동등 비교함.
    
2. **===**
    
    타입까지 동등 비교함.
    
    얕은 비교 연산자
    
3. **Object.is** 
    
    === 연산자에 몇가지 규칙이 더 추가된 조금 더 strict한 동등연산자
    
    그러나 얘도 깊은 비교 연산자는 아니다!!!
    
4. **shallowEqual**
    
    자바스크립트의 Object.is 를 이용해 만든 리액트의 동등 비교 함수
    
    얘는 깊이 1까지의 비교가 가능하다. 
    
    즉,      shallowEqual({ name: “eugene”}, {name:”eugene”}) → true // 깊이 1
    
    그러나 shallowEqual({ person: {name: “eugene”}}, { person: {name: “eugene”}}) → false //깊이 2
    

## 추가 공부

1. Polyfill이란?



---

# 1.2  자바스크립트 함수 딥다이브

## 1. 함수의 세 가지 선언 방식

1. 함수 선언문
    
    ```jsx
    function add(a,b) {
    	return a+b;
    }
    
    add(10,20);  // 30
    ```
    
2. 함수 표현식
    
    ```jsx
    var sum = function(a,b) {  // 혼란방지용으로 이렇게 함수 이름 생략. 어차피 이름있어도 그 이름으로 호출 불가능.
    	return a+b;
    }
    
    sum(10,20);  // 30
    ```
    
3. 화살표함수
    
    ```jsx
    function add(a,b) {
    	return a+b;
    }
    ```
    
    *화살표함수는 class의 constructor로 사용하지 못함
    

## 2. 함수 선언 방식 간 차이

### 1. 함수 선언문 vs 함수 표현식

호이스팅에서 차이가 난다. 

둘 다 호이스팅이 일어나지만, 함수선언문 방식은 함수 호이스팅, 함수 표현식은 그냥 호이스팅. 

- (함수 선언문 방식)
    
    **함수의 호이스팅**은 실행 전에 함수 선언문이 메모리에 등록됨 
    
    호출 먼저 선언 나중에 해도 잘 동작.
    
- (함수 표현식 방식)
    
    **변수에 대한 호이스팅**은 런타임 이전에 undefined로 등록된 후 런타임 시점에 함수가 할당이 된다. 
    
    따라서 호출 먼저 선언 나중에 한다면? 런타임 에러!
    

### 2. 일반 함수 vs 화살표 함수

- **화살표 함수의 this**
    
    화살표 함수는 함수 자체의 바인딩을 갖지 않는다.
    
    따라서 화살표 함수의 this는 상위 스코프의 this를 받아 사용한다.
    

- **일반 함수의 this**
    
    런타임 시점에 결정되는 this를 따른다.
    

## 3. IIFE(즉시실행함수)

: 정의하는 순간 즉시 단 한 번 호출되고 다시 호출되지 않는 함수

```jsx
(function add(a, b) {
		return a+b;
})(10,20);  // 30

((a, b) => {
		return a+b;
})(10,20);  // 30
```

왜 쓸까?

독립적인 함수 스코프 보장 + 리팩토링 용이 

## 4. 고차함수

: 함수를 인수로 받거나, 함수를 리턴하는 함수

: 예를 들어 map같은게 고차함수다. 

## 5. 앞으로 함수는 이렇게 만들자

1. **함수의 side effect를 최소화하도록**
    
    사이드이펙트란 함수가 아닌 함수 밖에 미치는 영향을 말한다.
    
    예를들어 콘솔출력, API 호출, 메타태그 변경 등이다
    
2. **가능한 짧게**
    
    ESLint에서는 50줄 넘어가면 좀 길다고 분류한다
    
3. **이름을 직관적이게**
    
    예를들면 useEffect에 넘겨주는 콜백함수에 이름을 붙여준다
    

## 추가공부

1. **호이스팅**
    
    마치 선언문이 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징
    
2. **일급객체**
    
    자바스크립트에서 함수는 “일급객체”다
    
    일급객체란, 다른 객체에 일반적으로 적용가능한 모든 연산을 지원하는 객체이다.
    
    즉 함수는 다른 함수의 인수가 될 수도, 리턴값이 될수도, 변수에 할당될 수도 있다.
    
3. **고차 컴포넌트**
    
    고차 함수가 뭔지 알았다면? 
    
    컴포넌트를 인수로 받고 다른 컴포넌트를 리턴하는 고차컴포넌트도 뭔지 알아보자

---

# 1.3 자바스크립트 클래스 딥다이브

## 키워드

- 생성자
- 프로퍼티
- getter setter
- 인스턴스 메서드 (프로토타입 메서드)
- 정적 메서드
- 상속

## 간략 구현법

```jsx

class Person extends Animal {

	// 생성자
	constructor(name, gender, age) {
		//프로퍼티
		this.name = name;
		this.gender = gender;
		this.age = age;
	}
	
	
	// 인스턴스 메소드
	sayHello() {
		console.log("안녕! 나는"+this.name+"이야 반가워!");
	}
	
	// 정적 메소드
	static sayHello() {
		console.log("안녕! 반가워");  // static 함수 안에서의 this 불가능. 왜? instance에 대해서가 아닌 class 자체에 대한 함수임.
	}
	
	// setter
	set nameSetter(name) {
		this.name = name;
	}
	
	// getter
	get nameGetter() {
		return this.name;
	}
```

## 사실 자바스크립트의 클래스는

프로토타입 함수로 구현되어있다.

---

# 1.4 자바스크립트 클로저 딥다이브

## 1. 클로저란?

- 함수와 함수가 선언된 **어휘적 환경(Lexical Scope)을 조합해 코딩하는 기법**
- 이때 어휘적 환경이란,
    
    변수가 코드 내부 어디에서 선언되었고 어떤 유효범위를 가지는지 이다.
    
- 클로저는 다른 말로는 자바스크립트는 함수레벨 스코프를 가지고 있다는 점을 이용하는 기법이다.
    
    외부함수의 호출이 끝나도 내부 함수는 자신이 선언된 외부함수의 환경을 기억하기 때문에 외부함수와 같은 값을 사용할 수 있는 기법이다.
    
- 대표적으로 useState가 있다.

( + 클로저는 코드 작성 순간 정적으로 결정된다. (런타임에 동적 결정되는것 X) )

## 2. Scope

스코프란, “변수의 유효 범위” 이다.

- 전역 레벨 스코프
- 함수 레벨 스코프
    
    **자바스크립트에서는 블록 단위 스코프를 따르지 않는다! 함수 레벨 스코프를 따른다!
    
    **중첩된 함수의 경우 가장 가까운 스코프부터 확인
    

## 3. 클로저의 활용

클로저를 왜 쓰는가와 직결

1. 변수의 캡슐화가 가능하다!
    - 변수의 직접적인 노출 막아 직접 수정 위험 제거
    - 변수의 접근 방식 제한 → 로그 남기는 등의 작업이 가능해짐

1. 함수형 프로그래밍의 중요한 개념인 “side effect가 없고 순수해야한다”는 목적 달성을 위함
    - 함수를 어휘적 스코프에 가두어 놓아 외부에 예상치못할 결과를 초래할 side effect를 제거

```jsx
function myCounter() {

	var count = 0;
	
	return {
		increase: function() {
			return ++count;
		}
		decrease: function() {
			return ++count;
		}
				increase: function() {
			return --count;
		}
		counter: function() {
			console.log("[로그] : 카운터에 접근함");
			return count;
		}

}
```

## 클로저 주의사항

클로저는 비용이 든다!

클로저는 생성시마다 어휘적 환경을 어디서 사용될지에 관계없이 무조건 저장한다. → 메모리 이슈


---

# 1.5 이벤트 루프와 비동기 통신

## 1. 자바스크립트는 싱글스레드 언어

자바스크립트 엔진(V8)이 싱글 스레드라 스택을 하나 밖에 안 가지고 있다.

자바스크립트는 싱글스레드 언어

(애초에 왜 싱글스레드로 설계했을까? 멀티스레드를 이용해 여러 스레드가 하나의 DOM을 조작한다면 동시성으로 인해 타이밍이슈로 DOM 표시에 문제가 생길 수 있다 + 애초에 자바스크립트 만들어질때 단순한+제한적인 일만 수행하기 위한 언어였다.)

### 싱글 스레드란?

하나의 프로그램 → 하나의 프로세스 (메모리 상 실행 단위)

하나의 프로세스 → 여러개의 스레드 (프로세스의 메모리 공유, 작업 동시실행 가능)

여러 개의 스레드를 통해서 하나의 프로그램은 병렬적으로 처리될 수 있다. 

이런 스레드가 하나라는 뜻은?

한 번에 하나의 일만 동기적으로 처리한다는 뜻. 
하나의 작업이 끝나기 전에 다음 작업이 실행되지 않는다 (Run-to-Completion)

## 2. 이벤트루프

**이벤트 루프의 동기 작업 처리**

- 호출스택이 비어있는지/작업이 남아있는지 확인하고, 
실행할 코드가 있다면 자바스크립트 엔진을 이용해 실행한다.
- 위의 두 과정은 동시에 일어날 수 없다. 자바스크립트 엔진의 단 하나뿐인 스레드를 이용하기 때문.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fa4cd899-cc5b-4e5a-956e-c42904d52473/9a2504a2-9576-465c-a0d9-4499203be1d9/Untitled.png)

**이벤트 루프의 비동기 작업 처리**

- **‘이벤트 루프’**가 자바스크립트 런타임 엔진(V8) **“외부에서”** 자바스크립트의 비동기 실행을 돕는다!
- 호출스택에 실행 중인 코드가 있는지, 태스크큐에 대기중인 함수가 있는지 반복해서 확인하고, 호출스택이 비었을때 태스크큐의 실행가능한 오래된 순서의 작업들을 태스크큐가 빌때까지 **실행한다.**
- 위의 비동기 함수들의 실행은 자바스크립트 런타임의 스레드에서 수행되지 않는다!!!
- 브라우저나 Node.js가 태스크큐가 할당된 별도의 스레드에서 이 작업들을 실행한다.
- setTimeOut이나 Web API 같은 비동기 함수들이 자바스크립트 엔진 외부에서 실행된 후
콜백이 태스크큐에 들어간다!
- 콜백이 실행가능해지는 때가 오면 태스크큐에서 호출스택으로 이동시켜 수행한다.

## 3. 콜스택(호출스택)

- 호출스택은 자바스크립트에서 **실행해야할** 코드나 함수를 순차적으로 담아둔다.
- 비동기 함수도 코드 순서에 따라 호출스택에 들어가기는 한다. 하지만 바로 나올뿐.
- Node.js나 브라우저에 의해 다른 외부 스레드에서 이벤트가 실행된다.
- 호출스택에서는 이 비동기 함수는 바로 나오고 콜백을 태스크큐에 넣는다.
    
    

## 4. 태스크큐

- 이벤트큐는 태스크큐를 한 개 이상 갖고있다.
- 이벤트 루프가 호출스택이 비워진걸 확인한 후에 
태스크큐가 비어있는지/수행할 비동기 콜백 함수 작업들이 남아있는지 확인한다.
- 태스크큐에 실행 가능한 작업이 있다면 오래된 순으로 실행한다.

## 5. 마이크로 태스크큐

- 마이크로 태스크큐는 태스크큐와 처리하는 작업이 다르다.
    
    ex) Promise,  MutationObserver, process.nextTick, queueMicroTask
    
- 마이크로 태스크큐는 태스크큐보다 우선순위가 높다.
- 마이크로 태스크큐가 비기 전까지는 태스크큐의 실행은 미뤄진다
- 렌더링 시점 : 마이크로  태스크큐 → **렌더링** → 태스크큐
- 태스크큐 작업은 하나가 끝날때마다 마이크로큐가 비어있는지 확인한다. 
따라서 태스크큐에 있는 작업이 끝날때마다 순차적으로 렌더링 된다.
- 동기 작업과 마이크로 태스크큐 작업은 렌더링 전에 수행이 완료되므로 한 번에 그려지지만, 태스크큐 작업은 작업 하나가 끝날때마다 다시 렌더링된다.
따라서 적절한 스코프로 클로저를 가둬두고, 어휘적 환경의 용량에 주의하자.
